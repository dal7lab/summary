<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 관계 궤적의 비밀 (v32 - 정적 인포그래픽)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Three.js 라이브러리 <head>에서 전역 로드 (No-Fail v24/v25 방식) -->
    <!-- 1. Three.js (Core)를 먼저 로드 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 2. OrbitControls (Add-on)를 나중에 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Google Fonts - Noto Sans KR -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <!-- MathJax (수학식 렌더링) 설정 -->
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #111827; /* bg-gray-900 (템플릿 스타일) */
        }
        .gradient-text {
            background: linear-gradient(to right, #4F46E5, #A855F7, #EC4899); /* v30/v31 스타일 */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .accordion-content { display: none; overflow: hidden; }
        
        /* [수정] 3D 캔버스 컨테이너 (dal7lab 스타일) */
        .threejs-container {
            position: relative;
            height: 50vh;
            width: 100%;
            min-height: 400px;
            background-color: #0c111c;
            border-radius: 0.5rem;
            border: 1px solid #374151;
            touch-action: none; 
        }
        .threejs-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* 2D 차트 컨테이너 (dal7lab 스타일) */
        .chart-container {
            position: relative;
            height: 50vh;
            width: 100%;
            min-height: 400px;
        }
        
        /* 테이블 스타일 (dal7lab 스타일) */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }
        th, td {
            border: 1px solid #4B5563; /* border-gray-600 */
            padding: 12px;
            text-align: center;
        }
        th {
            background-color: #374151; /* bg-gray-700 */
            color: #E5E7EB; /* text-gray-200 */
        }
        tbody tr:nth-child(odd) {
            background-color: #374151; /* bg-gray-700 */
        }
        tbody tr:nth-child(even) {
            background-color: #1F2937; /* bg-gray-800 */
        }

        /* 수식 스타일 (dal7lab 스타일) */
        .formula {
            font-size: 1.1rem;
            color: #D1D5DB; /* text-gray-300 */
            background: #1F2937; /* bg-gray-800 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            border: 1px solid #4B5563;
        }
        .prose-custom {
            color: #D1D5DB;
        }
        .prose-custom h3 {
            color: #FFFFFF;
            font-weight: 700;
            font-size: 1.25rem;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }
        .prose-custom ul {
            list-style-type: disc;
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body class="text-gray-200">

    <div class="container mx-auto max-w-7xl px-4 py-16"> <!-- [수정] max-w-7xl (더 넓게) -->

        <!-- 헤더 (템플릿 스타일) -->
        <header class="text-center mb-20">
            <h1 class="text-5xl md:text-6xl font-black mb-6 gradient-text">
                3D 관계 궤적의 0.001% 비밀
            </h1>
            <p class="text-2xl md:text-3xl font-bold text-gray-100 mb-8">로렌츠 어트랙터로 본 관계의 3가지 운명 (v32)</p>
        </header>

        <!-- 시뮬레이션 1: 혼돈 (템플릿 구조) -->
        <section class="mb-24">
            <h2 class="text-4xl font-extrabold text-left mb-8 pb-3 border-b border-gray-700">
                시뮬레이션 1: "격정적 롤러코스터" <span class="text-2xl font-normal text-pink-400">(Chaotic)</span>
            </h2>
            
            <!-- 듀얼 차트 (시간 + 궤적) -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- 차트 1a: 3D 궤적 (Phase Plot) -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h3 class="text-xl font-bold text-white mb-4">🔮 (A) 3D 관계 궤적 ($\rho = 28.0$)</h3>
                    <div class="threejs-container">
                        <canvas id="chart1_3d"></canvas>
                    </div>
                </div>
                <!-- 차트 1b: 2D 시간-긴장감 -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h3 class="text-xl font-bold text-white mb-4">📈 (B) 시간에 따른 긴장감($z$)</h3>
                     <div class="chart-container">
                        <canvas id="chart1_2d"></canvas>
                    </div>
                </div>
            </div>

            <!-- 테이블 1 (템플릿 스타일) -->
            <div class="overflow-x-auto my-8">
                <table>
                    <thead>
                        <tr>
                            <th>변수</th>
                            <th>$\rho$ (혼돈도)</th>
                            <th>$\sigma$ (민감도)</th>
                            <th>$\beta$ (안정성)</th>
                            <th>초기값 ($x,y,z$)</th>
                            <th>AI 진단</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>값</strong></td>
                            <td class="text-pink-400 font-bold">28.0 (> 24.74)</td>
                            <td>10.0</td>
                            <td>2.67</td>
                            <td>(1, 1, 1)</td>
                            <td class="text-pink-400 font-bold">혼돈 (카오스)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- 분석 1 (템플릿 스타일) -->
            <div class="bg-gray-800 p-8 rounded-2xl shadow-lg border border-gray-700 prose-custom">
                <h3 class="text-2xl font-bold text-pink-400 mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    시뮬레이션 1: AI 컨설팅
                </h3>
                <p><strong>진단:</strong> $\rho > 24.74$ 입니다. 관계가 '혼돈(Chaotic)' 상태, 즉 '이상한 어트랙터(Strange Attractor)'에 진입했습니다.</p>
                <p><strong>3D 궤적 분석 (A):</strong> 궤적이 (0,0,0)으로 수렴하거나 한 곳에 머물지 않고, 두 개의 중심(어트랙터)을 영원히 오갑니다. 이것이 "예측 불가능하지만 일정한 패턴을 가진" 혼돈의 본질입니다.</p>
                <p><strong>2D 긴장감 분석 (B):</strong> $z$축(긴장감)이 일정한 값으로 수렴하지 않고, 두 개의 중심을 오갈 때마다 격렬하게 진동합니다.</p>
                <p><strong>결론:</strong> 이 관계는 '격정적 롤러코스터'입니다. 예측 불가능하며, 초기 감정의 미세한 차이가 10초 뒤의 감정을 완전히 다르게 만듭니다(나비 효과). 관계가 파국으로 치닫지는 않지만, (0,0,0)으로 수렴하지도 않고 영원히 두 상태를 오갑니다.</p>
            </div>
        </section>

        <!-- 시뮬레이션 2: 안정 (템플릿 구조) -->
        <section class="mb-24">
            <h2 class="text-4xl font-extrabold text-left mb-8 pb-3 border-b border-gray-700">
                시뮬레이션 2: "안정적 수렴" <span class="text-2xl font-normal text-blue-400">(Stable)</span>
            </h2>
            
            <!-- 듀얼 차트 (시간 + 궤적) -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- 차트 2a: 3D 궤적 (Phase Plot) -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h3 class="text-xl font-bold text-white mb-4">🔮 (A) 3D 관계 궤적 ($\rho = 20.0$)</h3>
                    <div class="threejs-container">
                        <canvas id="chart2_3d"></canvas>
                    </div>
                </div>
                <!-- 차트 2b: 2D 시간-긴장감 -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h3 class="text-xl font-bold text-white mb-4">📈 (B) 시간에 따른 긴장감($z$)</h3>
                     <div class="chart-container">
                        <canvas id="chart2_2d"></canvas>
                    </div>
                </div>
            </div>

            <!-- 테이블 2 (템플릿 스타일) -->
            <div class="overflow-x-auto my-8">
                <table>
                    <thead>
                        <tr>
                            <th>변수</th>
                            <th>$\rho$ (혼돈도)</th>
                            <th>$\sigma$ (민감도)</th>
                            <th>$\beta$ (안정성)</th>
                            <th>초기값 ($x,y,z$)</th>
                            <th>AI 진단</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>값</strong></td>
                            <td class="text-blue-400 font-bold">20.0 (< 24.74)</td>
                            <td>10.0</td>
                            <td>2.67</td>
                            <td>(1, 1, 1)</td>
                            <td class="text-blue-400 font-bold">안정 (수렴)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- 분석 2 (템플릿 스타일) -->
            <div class="bg-gray-800 p-8 rounded-2xl shadow-lg border border-gray-700 prose-custom">
                <h3 class="text-2xl font-bold text-blue-400 mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    시뮬레이션 2: AI 컨설팅
                </h3>
                <p><strong>진단:</strong> $1 < \rho < 24.74$ 입니다. 관계가 '혼돈' 상태가 아닌 '안정된' 상태입니다.</p>
                <p><strong>3D 궤적 분석 (A):</strong> 궤적이 초반에 잠시 방황하다가, 이내 (8.1, 8.1, 19.0) 지점 근처의 '안정점(Fixed Point)' 중 하나로 수렴하여 멈춥니다.</p>
                <p><strong>2D 긴장감 분석 (B):</strong> $z$축(긴장감)이 초반에 잠시 요동치다가, $z=19.0$ 이라는 일정한 값으로 수렴하여 더 이상 변하지 않습니다.</p>
                <p><strong>결론:</strong> 축하합니다. 이 관계는 예측 가능하며 안정적입니다. '격정'은 없지만 '평화'가 있습니다. 궤적이 (0,0,0)이 아닌 특정 지점으로 수렴하는 것은 두 사람이 '무관심'이 아닌 '안정된 애정' 상태에 도달했음을 의미합니다.</p>
            </div>
        </section>
        
        <!-- 시뮬레이션 3: 무관심 (템플릿 구조) -->
        <section class="mb-24">
            <h2 class="text-4xl font-extrabold text-left mb-8 pb-3 border-b border-gray-700">
                시뮬레이션 3: "무관심과 소멸" <span class="text-2xl font-normal text-gray-500">(Indifferent)</span>
            </h2>
            
            <!-- 듀얼 차트 (시간 + 궤적) -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- 차트 3a: 3D 궤적 (Phase Plot) -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h3 class="text-xl font-bold text-white mb-4">🔮 (A) 3D 관계 궤적 ($\rho = 0.5$)</h3>
                    <div class="threejs-container">
                        <canvas id="chart3_3d"></canvas>
                    </div>
                </div>
                <!-- 차트 3b: 2D 시간-긴장감 -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h3 class="text-xl font-bold text-white mb-4">📈 (B) 시간에 따른 긴장감($z$)</h3>
                     <div class="chart-container">
                        <canvas id="chart3_2d"></canvas>
                    </div>
                </div>
            </div>

            <!-- 테이블 3 (템플릿 스타일) -->
            <div class="overflow-x-auto my-8">
                <table>
                    <thead>
                        <tr>
                            <th>변수</th>
                            <th>$\rho$ (혼돈도)</th>
                            <th>$\sigma$ (민감도)</th>
                            <th>$\beta$ (안정성)</th>
                            <th>초기값 ($x,y,z$)</th>
                            <th>AI 진단</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>값</strong></td>
                            <td class="text-gray-500 font-bold">0.5 (< 1.0)</td>
                            <td>10.0</td>
                            <td>2.67</td>
                            <td>(10, 10, 10)</td>
                            <td class="text-gray-500 font-bold">무관심 (소멸)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- 분석 3 (템플릿 스타일) -->
            <div class="bg-gray-800 p-8 rounded-2xl shadow-lg border border-gray-700 prose-custom">
                <h3 class="text-2xl font-bold text-gray-500 mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    시뮬레이션 3: AI 컨설팅
                </h3>
                <p><strong>진단:</strong> $\rho < 1$ 입니다. 관계의 '혼돈 에너지'가 너무 낮습니다.</p>
                <p><strong>3D 궤적 분석 (A):</strong> 궤적이 (10,10,10)이라는 높은 에너지에서 시작했음에도 불구하고, 즉시 힘을 잃고 (0,0,0) 원점을 향해 나선형을 그리며 수렴합니다.</p>
                <p><strong>2D 긴장감 분석 (B):</strong> $z$축(긴장감)이 10에서 시작하여 0을 향해 지수적으로 감쇠합니다.</p>
                <p><strong>결론:</strong> 이것은 '안정'이 아니라 '소멸'입니다. 두 사람의 관계 에너지가 완전히 방전되었습니다. $\rho$값이 0에 가까우면, $x$와 $y$의 상호작용이 $z$를 만들지 못하고, 모든 감정이 0으로 붕괴됩니다. 관계를 되돌리려면 $\rho$값을 높이는 외부의 강력한 자극이 필요합니다.</p>
            </div>
        </section>

        <!-- 시뮬레이션 원리 (아코디언, 템플릿 구조) -->
        <section class="mt-24">
            <h2 class="text-4xl font-extrabold text-center mb-12 gradient-text">
                '3D 관계 동역학 시뮬레이터' 작동 원리
            </h2>
            <div class="max-w-4xl mx-auto space-y-4">
                
                <div class="accordion-item bg-gray-800 rounded-lg shadow-lg border border-gray-700">
                    <button class="accordion-button w-full flex justify-between items-center text-left p-6">
                        <span class="text-xl font-semibold text-gray-100">1. '로렌츠 어트랙터' 모델링</span>
                        <svg class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content px-6 pb-6 text-lg">
                        <p class="text-gray-300 leading-relaxed mb-4">
                            이 시뮬레이션은 3D 혼돈(Chaos) 이론의 시초인 '로렌츠 어트랙터' 모델을 기반으로 합니다. 3개의 변수가 서로를 참조하여 다음 상태를 결정하는 비선형 연립 미분 방정식입니다.
                        </p>
                        <div class="formula">
                            $$ \frac{dx}{dt} = \sigma (y - x) $$
                            $$ \frac{dy}{dt} = x (\rho - z) - y $$
                            $$ \frac{dz}{dt} = xy - \beta z $$
                        </div>
                    </div>
                </div>
                
                <div class="accordion-item bg-gray-800 rounded-lg shadow-lg border border-gray-700">
                    <button class="accordion-button w-full flex justify-between items-center text-left p-6">
                        <span class="text-xl font-semibold text-gray-100">2. 변수의 "관계적" 해석</span>
                        <svg class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content p-6 text-lg prose-custom">
                        <p>이 모델을 전문가는 다음과 같이 '관계'에 대입하여 분석합니다.</p>
                        <ul>
                            <li><strong>$x$ (영희의 감정):</strong> $y$(철수)의 감정에 민감하게 반응($\sigma$)합니다. ($\dot{x} \propto \sigma(y-x)$)</li>
                            <li><strong>$y$ (철수의 감정):</strong> $x$(영희)의 감정에 반응하지만, $z$(긴장감)가 높을수록($\rho-z$) 그 반응이 억제됩니다.</li>
                            <li><strong>$z$ (관계의 긴장감):</strong> $x$와 $y$가 상호작용($xy$)할수록 높아지고, 스스로 안정($-\beta z$)되려 합니다.</li>
                        </ul>
                    </div>
                </div>

                <div class="accordion-item bg-gray-800 rounded-lg shadow-lg border border-gray-700">
                    <button class="accordion-button w-full flex justify-between items-center text-left p-6">
                        <span class="text-xl font-semibold text-gray-100">3. $\rho$ (로): 혼돈의 마스터 변수</span>
                        <svg class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content p-6 text-lg prose-custom">
                        <p>다른 변수($\sigma=10, \beta=8/3$)가 고정일 때, $\rho$는 관계의 운명을 결정합니다.</p>
                         <ul>
                            <li><strong>$\rho < 1$:</strong> (무관심) 모든 감정이 (0,0,0)으로 수렴하여 소멸합니다.</li>
                            <li><strong>$1 < \rho < 24.74$:</strong> (안정) 감정이 2개의 안정된 지점(Fixed Point) 중 하나로 수렴합니다. 예측 가능하고 안정적입니다.</li>
                            <li><strong>$\rho > 24.74$:</strong> (혼돈) 관계가 '이상한 어트랙터(Strange Attractor)' 상태가 됩니다. 궤적은 두 지점 사이를 예측 불가능하게 오가며, 초기 감정($x_0$)의 미세한 차이가 완전히 다른 궤적을 만듭니다 (나비 효과).</li>
                        </ul>
                    </div>
                </div>

            </div>
        </section>

    </div>

    <!-- [v32] 정적 인포그래픽 스크립트 -->
    <script>
        // [v24] "비밀 코드": window.load를 사용하여 모든 라이브러리(THREE, OrbitControls, Chart)가 로드된 후 앱을 실행합니다.
        window.addEventListener('load', initializeApp);

        // --- 1. 시뮬레이션 핵심 로직 (로렌츠) ---
        function runLorenzSimulation(params, steps = 5000, dt = 0.01) {
            let { sigma, rho, beta, x0, y0, z0 } = params;
            let x = x0, y = y0, z = z0;
            const points = [], t_labels = [], z_history = [];
            
            for (let i = 0; i < steps; i++) {
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;
                x += dx * dt;
                y += dy * dt;
                z += dz * dt;
                points.push(new THREE.Vector3(x, y, z));
                t_labels.push((i * dt).toFixed(2));
                z_history.push(z);
            }
            return { points, t_labels, z_history };
        }
        
        // --- 2. [v32] 3D 씬 생성 팩토리 ---
        function createThreeJSScene(canvasId) {
            const container = document.getElementById(canvasId).parentElement; // .threejs-container
            const canvas = document.getElementById(canvasId);
            if (!container || !canvas) return null;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 40);
            
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0); 
            
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 100;

            scene.add(new THREE.AmbientLight(0xaaaaaa));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            const axesHelper = new THREE.AxesHelper(20);
            scene.add(axesHelper); // (v24: setColors() 버그 수정됨)
            
            // 리사이즈 핸들러
            const onResize = () => {
                if (container.clientWidth > 0 && container.clientHeight > 0) {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }
            };
            window.addEventListener('resize', onResize, false);

            // 렌더링 루프
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            return { scene, camera, renderer, controls };
        }
        
        // --- 3. [v32] 3D 궤적 업데이트 (씬 객체 필요) ---
        function updateTrajectory(scene, points, color = 0xA855F7) {
            if (!scene) return;
            
            // 기존 궤적(Mesh) 찾아서 제거
            const oldTrajectory = scene.getObjectByName("trajectory");
            if (oldTrajectory) {
                scene.remove(oldTrajectory);
                oldTrajectory.geometry.dispose();
                oldTrajectory.material.dispose();
            }
            
            const path = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(path, 2000, 0.2, 8, false); 
            const material = new THREE.MeshPhongMaterial({ color: color, shininess: 30 });
            
            const trajectoryTube = new THREE.Mesh(geometry, material);
            trajectoryTube.name = "trajectory"; // 제거를 위해 이름 부여
            scene.add(trajectoryTube);
            
            // 바운딩 박스 (v30의 큐브)
            const oldBox = scene.getObjectByName("bounding_box");
            if (oldBox) {
                scene.remove(oldBox);
                oldBox.geometry.dispose();
                oldBox.material.dispose();
            }
            
            geometry.computeBoundingBox();
            const boundingBox = geometry.boundingBox;
            const boxGeometry = new THREE.BoxGeometry(
                boundingBox.max.x - boundingBox.min.x + 5, 
                boundingBox.max.y - boundingBox.min.y + 5, 
                boundingBox.max.z - boundingBox.min.z + 5
            );
            const wireframe = new THREE.WireframeGeometry(boxGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x555555, linewidth: 1 });
            const wireframeCube = new THREE.LineSegments(wireframe, lineMaterial);
            wireframeCube.position.copy(boundingBox.getCenter(new THREE.Vector3()));
            wireframeCube.name = "bounding_box";
            scene.add(wireframeCube);
        }
        
        // --- 4. 2D 차트 생성 함수 ---
        function createTimeSeriesChart(canvasId, data, color) {
            const chartCanvas = document.getElementById(canvasId)?.getContext('2d');
            if (!chartCanvas) return;
            
            new Chart(chartCanvas, {
                type: 'line',
                data: {
                    labels: data.t_labels,
                    datasets: [
                        {
                            label: 'z (관계의 긴장감)',
                            data: data.z_history,
                            borderColor: color,
                            backgroundColor: `${color}30`,
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top', labels: { color: '#E5E7EB', font: { size: 14 } } },
                        tooltip: { mode: 'index', intersect: false, callbacks: { title: (items) => `Time: ${items[0].label}s` } }
                    },
                    scales: {
                        x: { title: { display: true, text: '시간 (Time)', color: '#9CA3AF' }, ticks: { color: '#9CA3AF', maxTicksLimit: 10 }, grid: { color: '#374151' } },
                        y: { title: { display: true, text: 'Z축 (긴장감)', color: '#9CA3AF' }, ticks: { color: '#9CA3AF' }, grid: { color: '#374151' }, grace: '10%' }
                    },
                    elements: { point: { radius: 0, hitRadius: 10, hoverRadius: 5 } }
                }
            });
        }
        
        // --- 5. 메인 실행 함수 ---
        function initializeApp() {
            console.log("v32: 모든 리소스 로드 완료 (window.load). 앱 초기화 시작...");
            
            // 라이브러리 로드 최종 확인
            if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined' || typeof Chart === 'undefined') {
                const errorMsg = "치명적 오류: 3D/2D 라이브러리 로드에 실패했습니다! (v32) 새로고침 후에도 문제가 지속되면 브라우저 캐시를 삭제해 주세요.";
                console.error(errorMsg);
                alert(errorMsg); 
                return;
            }
            console.log("v32: 모든 라이브러리(THREE, OrbitControls, Chart) 로드 확인 완료.");

            // --- 시나리오 정의 ---
            const params_chaotic = { sigma: 10.0, rho: 28.0, beta: 2.67, x0: 1.0, y0: 1.0, z0: 1.0 };
            const params_stable = { sigma: 10.0, rho: 20.0, beta: 2.67, x0: 1.0, y0: 1.0, z0: 1.0 };
            const params_indifferent = { sigma: 10.0, rho: 0.5, beta: 2.67, x0: 10.0, y0: 10.0, z0: 10.0 };
            
            // --- 시뮬레이션 실행 ---
            const data_chaotic = runLorenzSimulation(params_chaotic);
            const data_stable = runLorenzSimulation(params_stable);
            const data_indifferent = runLorenzSimulation(params_indifferent);
            
            // --- 3D 씬 생성 및 렌더링 ---
            try {
                const scene1 = createThreeJSScene('chart1_3d');
                updateTrajectory(scene1.scene, data_chaotic.points, 0xF472B6); // Pink

                const scene2 = createThreeJSScene('chart2_3d');
                updateTrajectory(scene2.scene, data_stable.points, 0x3B82F6); // Blue
                
                const scene3 = createThreeJSScene('chart3_3d');
                updateTrajectory(scene3.scene, data_indifferent.points, 0x6B7280); // Gray
            } catch (e) {
                console.error("Three.js 씬 생성 실패:", e);
                alert("3D 렌더링 엔진 초기화에 실패했습니다: " + e.message);
            }
            
            // --- 2D 차트 렌더링 ---
            createTimeSeriesChart('chart1_2d', data_chaotic, '#F472B6');
            createTimeSeriesChart('chart2_2d', data_stable, '#3B82F6');
            createTimeSeriesChart('chart3_2d', data_indifferent, '#6B7280');
            
            // --- 아코디언 스크립트 ---
            document.querySelectorAll('.accordion-button').forEach(button => {
                button.addEventListener('click', () => {
                    const content = button.nextElementSibling;
                    const icon = button.querySelector('svg');
                    const isOpening = content.style.display !== 'block';
                    
                    document.querySelectorAll('.accordion-content').forEach(c => {
                        if (c !== content) {
                            c.style.display = 'none';
                            c.previousElementSibling.querySelector('svg').style.transform = 'rotate(0deg)';
                        }
                    });

                    if (isOpening) {
                        content.style.display = 'block';
                        icon.style.transform = 'rotate(180deg)';
                        if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                            MathJax.typesetPromise([content]).catch(function (err) {
                                console.log('MathJax typeset error:', err);
                            });
                        }
                    } else {
                         content.style.display = 'none';
                         icon.style.transform = 'rotate(0deg)';
                    }
                });
            });

            // 초기 MathJax 렌더링 (아코디언 밖의 텍스트)
            if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                 MathJax.typesetPromise().catch(function (err) {
                    console.log('MathJax 초기 렌더링 오류:', err);
                });
            }
            
            console.log("앱 초기화 완료. (v32)");
        }
        
    </script>
</body>
</html>