<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 관계 동역학 시뮬레이터 (v31 - Rollback->perfect)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- [v23] Three.js 라이브러리 <head>에서 전역 로드 -->
    <!-- 1. Three.js (Core)를 먼저 로드 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 2. OrbitControls (Add-on)를 나중에 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Google Fonts - Noto Sans KR -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <!-- MathJax (수학식 렌더링) 설정 (v24 원본) -->
    <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- v24 원본 스타일 -->
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        .gradient-text {
            background: linear-gradient(to right, #4F46E5, #A855F7, #EC4899); /* Indigo -> Purple -> Pink */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .accordion-content { display: none; overflow: hidden; }
        
        .threejs-container {
            position: relative;
            height: 60vh;
            width: 100%;
            min-height: 450px;
            background-color: #0c111c;
            border-radius: 0.5rem;
            border: 1px solid #374151;
            touch-action: none; 
        }
        #threeJSCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .chart-container {
            position: relative;
            height: 40vh;
            width: 100%;
            min-height: 300px;
        }
        
        .formula {
            font-size: 1.1rem; color: #D1D5DB; background: #1F2937;
            padding: 1.5rem; border-radius: 0.5rem; overflow-x: auto; border: 1px solid #4B5563;
        }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px; background: #374151;
            border-radius: 5px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px; background: #A855F7; /* Purple */
            border-radius: 50%; cursor: pointer; transition: background 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: #A855F7;
            border-radius: 50%; cursor: pointer; border: none;
        }
    </style>
</head>
<body class="text-gray-200">

    <div class="container mx-auto max-w-7xl px-4 py-16">

        <!-- 헤더 (v30 타이틀) -->
        <header class="text-center mb-16">
            <h1 class="text-5xl md:text-6xl font-black mb-6 gradient-text">
                3D 관계 동역학 시뮬레이터 (v30)
            </h1>
            <p class="text-2xl md:text-3xl font-bold text-gray-100">
                0.001%의 비밀: 로렌츠 어트랙터(Lorenz Attractor) 모델
            </p>
        </header>

        <!-- v24 원본 HTML 구조 (그리드) -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- 1. 컨트롤 패널 (L) (v24 원본) -->
            <div class="lg:col-span-1 bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700 h-fit">
                <h2 class="text-2xl font-bold text-white mb-6 pb-3 border-b border-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.835 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.532 1.532 0 012.287-.947c1.372.835 2.942-.734 2.106-2.106a1.532 1.532 0 01-.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01.947-2.287c.835-1.372-.734-2.942-2.106-2.106A1.532 1.532 0 0111.49 3.17zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" /></svg>
                    "비밀 코드" 변수 조작
                </h2>
                
                <div class="space-y-6">
                    <!-- 로렌츠 변수 -->
                    <div>
                        <label for="param-rho" class="flex justify-between items-center text-sm font-medium text-gray-300">
                            <span>$\rho$ (로): 관계의 혼돈도</span>
                            <span id="val-rho" class="font-bold text-purple-300 text-base">28.0</span>
                        </label>
                        <input type="range" id="param-rho" min="1" max="50" value="28.0" step="0.1" class="w-full mt-2">
                    </div>
                    <div>
                        <label for="param-sigma" class="flex justify-between items-center text-sm font-medium text-gray-300">
                            <span>$\sigma$ (시그마): 상호 민감도</span>
                            <span id="val-sigma" class="font-bold text-purple-300 text-base">10.0</span>
                        </label>
                        <input type="range" id="param-sigma" min="1" max="20" value="10.0" step="0.1" class="w-full mt-2">
                    </div>
                    <div>
                        <label for="param-beta" class="flex justify-between items-center text-sm font-medium text-gray-300">
                            <span>$\beta$ (베타): 감정 안정성</span>
                            <span id="val-beta" class="font-bold text-purple-300 text-base">2.67</span>
                        </label>
                        <input type="range" id="param-beta" min="0.1" max="5" value="2.6667" step="0.01" class="w-full mt-2">
                    </div>

                    <!-- 초기 감정 -->
                    <div class="pt-4 border-t border-gray-600">
                        <label for="param-x0" class="flex justify-between items-center text-sm font-medium text-gray-300">
                            <span>$x_0$ (영희 초기 감정)</span>
                            <span id="val-x0" class="font-bold text-pink-400 text-base">1.0</span>
                        </label>
                        <input type="range" id="param-x0" min="-10" max="10" value="1.0" step="0.1" class="w-full mt-2">
                    </div>
                    <div>
                        <label for="param-y0" class="flex justify-between items-center text-sm font-medium text-gray-300">
                            <span>$y_0$ (철수 초기 감정)</span>
                            <span id="val-y0" class="font-bold text-blue-400 text-base">1.0</span>
                        </label>
                        <input type="range" id="param-y0" min="-10" max="10" value="1.0" step="0.1" class="w-full mt-2">
                    </div>
                    <div>
                        <label for="param-z0" class="flex justify-between items-center text-sm font-medium text-gray-300">
                            <span>$z_0$ (초기 긴장감)</span>
                            <span id="val-z0" class="font-bold text-white text-base">1.0</span>
                        </label>
                        <input type="range" id="param-z0" min="-10" max="10" value="1.0" step="0.1" class="w-full mt-2">
                    </div>
                </div>

                <!-- 프리셋 버튼 (v24 원본) -->
                <div class="mt-8 pt-6 border-t border-gray-600">
                    <h3 class="text-lg font-semibold text-white mb-3">관계 궤적 프리셋</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <button id="preset-chaotic" class="w-full px-3 py-2 bg-pink-600 text-white rounded-lg shadow hover:bg-pink-700 transition text-sm font-medium">혼돈 (클래식)</button>
                        <button id="preset-stable" class="w-full px-3 py-2 bg-blue-600 text-white rounded-lg shadow hover:bg-blue-700 transition text-sm font-medium">안정 (수렴)</button>
                        <button id="preset-indifferent" class="w-full px-3 py-2 bg-gray-600 text-white rounded-lg shadow hover:bg-gray-700 transition text-sm font-medium">무관심 (소멸)</button>
                        <button id="preset-intense" class="w-full px-3 py-2 bg-red-600 text-white rounded-lg shadow hover:bg-red-700 transition text-sm font-medium">격렬한 혼돈</button>
                    </div>
                </div>
            </div>

            <!-- 2. 그래프 및 해석 (R) (v24 원본) -->
            <div class="lg:col-span-2 space-y-8">
                
                <!-- [차트 1] 3D 궤적 (Three.js) -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h2 class="text-3xl font-bold text-white mb-4">
                        <span class="text-purple-400">3D</span>: 관계 궤적 (Phase Plot)
                    </h2>
                    <div class="threejs-container">
                        <canvas id="threeJSCanvas"></canvas>
                    </div>
                    <p class="text-center text-sm text-gray-400 mt-2">마우스로 궤적을 드래그, 줌, 패닝하여 탐색할 수 있습니다.</p>
                </div>
                
                <!-- [차트 2] 2D 시간-긴장감 (Chart.js) -->
                <div class="bg-gray-800 p-6 rounded-2xl shadow-xl border border-gray-700">
                    <h2 class="text-3xl font-bold text-white mb-4">
                        <span class="text-cyan-400">2D</span>: 시간(t)에 따른 긴장감(z) 변화
                    </h2>
                    <div class="chart-container">
                        <canvas id="timeSeriesChart"></canvas>
                    </div>
                </div>
                
                <!-- AI 혼돈 컨설팅 (v30 타이틀) -->
                <div class="bg-gray-800 p-8 rounded-2xl shadow-xl border border-gray-700">
                    <h2 class="text-2xl font-bold text-white mb-6 pb-3 border-b border-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        AI 관계 컨설팅 (v30)
                    </h2>
                    <div id="ai-consulting-report" class="text-lg text-gray-300 leading-relaxed space-y-3">
                        <!-- JS로 동적 업데이트 -->
                    </div>
                </div>

                <!-- 전문가용 동적 분석 (v30 타이틀) -->
                <div class="bg-gray-800 p-8 rounded-2xl shadow-xl border border-gray-700">
                    <h2 class="text-2xl font-bold text-white mb-6 pb-3 border-b border-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path d="M10 2a6 6 0 00-6 6v3.586l-1.707 1.707A1 1 0 003 15v4a1 1 0 001 1h12a1 1 0 001-1v-4a1 1 0 00-.293-.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z" /></svg>
                        전문가용 동적계 분석
                    </h2>
                    <div id="expert-analysis-report" class="text-lg text-gray-300 leading-relaxed space-y-3">
                        <!-- JS로 동적 업데이트 -->
                    </div>
                </div>
            </div>
        </div>

        <!-- 3. 시뮬레이션 원리 (아코디언) (v30 타이틀) -->
        <section class="mt-24">
            <h2 class="text-4xl font-extrabold text-center mb-12 gradient-text">
                 '3D 관계 동역학 시뮬레이터' 작동 원리
            </h2>
            <div class="max-w-4xl mx-auto space-y-4">
                
                <div class="accordion-item bg-gray-800 rounded-lg shadow-lg border border-gray-700">
                    <button class="accordion-button w-full flex justify-between items-center text-left p-6">
                        <span class="text-xl font-semibold text-gray-100">1. 로렌츠 어트랙터 (The 0.001% Model)</span>
                        <svg class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content px-6 pb-6 text-lg">
                        <p class="text-gray-300 leading-relaxed mb-4">
                            이 시뮬레이션은 3D 혼돈(Chaos) 이론의 시초인 '로렌츠 어트랙터' 모델을 기반으로 합니다. 3개의 변수가 서로를 참조하여 다음 상태를 결정하는 비선형 연립 미분 방정식입니다.
                        </p>
                        <div class="formula">
                            $$ \frac{dx}{dt} = \sigma (y - x) $$
                            $$ \frac{dy}{dt} = x (\rho - z) - y $$
                            $$ \frac{dz}{dt} = xy - \beta z $$
                        </div>
                    </div>
                </div>
                
                <div class="accordion-item bg-gray-800 rounded-lg shadow-lg border border-gray-700">
                    <button class="accordion-button w-full flex justify-between items-center text-left p-6">
                        <span class="text-xl font-semibold text-gray-100">2. 변수의 "관계적" 해석</span>
                        <svg class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content p-6 text-lg prose-custom">
                        <p>이 모델을 0.001% 전문가는 다음과 같이 '관계'에 대입하여 분석합니다.</p>
                        <ul>
                            <li><strong>$x$ (영희의 감정):</strong> $y$(철수)의 감정에 민감하게 반응($\sigma$)합니다. ($\dot{x} \propto \sigma(y-x)$)</li>
                            <li><strong>$y$ (철수의 감정):</strong> $x$(영희)의 감정에 반응하지만, $z$(긴장감)가 높을수록($\rho-z$) 그 반응이 억제됩니다.</li>
                            <li><strong>$z$ (관계의 긴장감):</strong> $x$와 $y$가 상호작용($xy$)할수록 높아지고, 스스로 안정($-\beta z$)되려 합니다.</li>
                        </ul>
                    </div>
                </div>

                <div class="accordion-item bg-gray-800 rounded-lg shadow-lg border border-gray-700">
                    <button class="accordion-button w-full flex justify-between items-center text-left p-6">
                        <span class="text-xl font-semibold text-gray-100">3. $\rho$ (로): 혼돈의 마스터 변수</span>
                        <svg class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div class="accordion-content p-6 text-lg prose-custom">
                        <p>다른 변수($\sigma=10, \beta=8/3$)가 고정일 때, $\rho$는 관계의 운명을 결정합니다.</p>
                         <ul>
                            <li><strong>$\rho < 1$:</strong> (무관심) 모든 감정이 (0,0,0)으로 수렴하여 소멸합니다.</li>
                            <li><strong>$1 < \rho < 24.74$:</strong> (안정) 감정이 2개의 안정된 지점(Fixed Point) 중 하나로 수렴합니다. 예측 가능하고 안정적입니다.</li>
                            <li><strong>$\rho > 24.74$:</strong> (혼돈) 관계가 '이상한 어트랙터(Strange Attractor)' 상태가 됩니다. 궤적은 두 지점 사이를 예측 불가능하게 오가며, 초기 감정($x_0$)의 미세한 차이가 완전히 다른 궤적을 만듭니다 (나비 효과).</li>
                        </ul>
                    </div>
                </div>

            </div>
        </section>

    </div>

    <!-- [v30] 스크립트 (튜브/큐브 로직 + Math Error 수정) -->
    <script>
        // [v24] "비밀 코드": 모든 라이브러리가 <head>에서 로드되길 기다린 후,
        // 'load' 이벤트가 발생하면 앱을 초기화합니다.
        window.addEventListener('load', initializeApp);

        // [v30] 전역 변수 수정: trajectoryLine -> trajectoryTube, wireframeCube 추가
        let scene, camera, renderer, controls, trajectoryTube, wireframeCube;
        let timeSeriesChart;
        
        const inputs = {};
        const values = {};
        const paramIds = ['sigma', 'rho', 'beta', 'x0', 'y0', 'z0'];
        let aiConsultingReport = null;
        let expertAnalysisReport = null;
        let animationFrameId = null;

        // --- 1. 시뮬레이션 핵심 로직 (로렌츠) (v24 원본) ---
        function runLorenzSimulation(params, steps = 5000, dt = 0.01) {
            let { sigma, rho, beta, x0, y0, z0 } = params;
            let x = x0, y = y0, z = z0;

            const points = []; // 3D 궤적
            const t_labels = []; // 2D 차트 (시간)
            const z_history = []; // 2D 차트 (Z축)
            
            for (let i = 0; i < steps; i++) {
                const dx = sigma * (y - x);
                const dy = x * (rho - z) - y;
                const dz = x * y - beta * z;

                x += dx * dt;
                y += dy * dt;
                z += dz * dt;

                points.push(new THREE.Vector3(x, y, z));
                t_labels.push((i * dt).toFixed(2));
                z_history.push(z);
            }
            return { points, t_labels, z_history };
        }
        
        // --- 2. Three.js 초기화 및 업데이트 (v24 원본) ---
        function initThreeJS() {
            const container = document.querySelector('.threejs-container');
            const canvas = document.getElementById('threeJSCanvas');

            if (!container || !canvas) {
                console.error("Three.js 컨테이너 또는 캔버스를 찾을 수 없습니다.");
                return;
            }
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 40);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0); 
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 100;

            // v24 원본 조명 (v30: Tube 재질에 필요)
            scene.add(new THREE.AmbientLight(0xaaaaaa));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            // [v24] "비밀 코드" 수정:
            // .setColors()는 r128에 존재하지 않는 함수입니다.
            // 기본 RGB 축 (X:Red, Y:Green, Z:Blue)을 사용합니다.
            const axesHelper = new THREE.AxesHelper(20);
            // axesHelper.setColors(...) // <- 이 줄이 v23의 오류 원인
            scene.add(axesHelper);
            
            window.addEventListener('resize', () => {
                if (!container || !camera || !renderer) return;
                // [v30] 0x0 리사이즈 방지
                if (container.clientWidth > 0 && container.clientHeight > 0) {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }
            }, false);

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animate();
        }
        
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (controls) {
                controls.update();
            }
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // [v30] 수정: 3D 궤적 업데이트 (Tube + Cube) (v29 로직)
        function updateTrajectory(points) {
            if (!scene) return;
            
            // 1. 기존 궤적(튜브) 및 큐브 제거
            if (trajectoryTube) {
                scene.remove(trajectoryTube);
                trajectoryTube.geometry.dispose();
                trajectoryTube.material.dispose();
            }
            if (wireframeCube) {
                scene.remove(wireframeCube);
                wireframeCube.geometry.dispose();
                wireframeCube.material.dispose();
            }
            
            // 2. 튜브(Tube) 지오메트리 생성 (CatmullRomCurve3 필요)
            const path = new THREE.CatmullRomCurve3(points);
            // (경로, 튜브 분할 수, 튜브 굵기, 튜브 원형 분할 수, 닫힘 여부)
            const geometry = new THREE.TubeGeometry(path, 2000, 0.2, 8, false); 
            
            // v24의 조명을 활용하기 위해 MeshPhongMaterial 사용
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xA855F7, // Purple
                shininess: 30    // 광택
            });
            
            trajectoryTube = new THREE.Mesh(geometry, material);
            scene.add(trajectoryTube);

            // 3. 와이어프레임 큐브 (Bounding Box) 추가
            geometry.computeBoundingBox();
            const boundingBox = geometry.boundingBox;

            // 바운딩 박스 기준으로 큐브 지오메트리 생성 (약간의 여백 +5)
            const boxGeometry = new THREE.BoxGeometry(
                boundingBox.max.x - boundingBox.min.x + 5, 
                boundingBox.max.y - boundingBox.min.y + 5, 
                boundingBox.max.z - boundingBox.min.z + 5
            );
            
            const wireframe = new THREE.WireframeGeometry(boxGeometry);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x555555, // 어두운 회색
                linewidth: 1
            });

            wireframeCube = new THREE.LineSegments(wireframe, lineMaterial);
            
            // 큐브의 중심을 튜브의 중심과 일치시킴
            wireframeCube.position.copy(boundingBox.getCenter(new THREE.Vector3()));
            
            scene.add(wireframeCube);
        }
        
        // --- 3. 2D 차트 (Chart.js) 업데이트 (v24 원본) ---
        function updateTimeSeriesChart(data) {
            const chartCanvas = document.getElementById('timeSeriesChart')?.getContext('2d');
            if (!chartCanvas) return;
            
            if (timeSeriesChart) {
                timeSeriesChart.data.labels = data.t_labels;
                timeSeriesChart.data.datasets[0].data = data.z_history;
                timeSeriesChart.update();
            } else {
                timeSeriesChart = new Chart(chartCanvas, {
                    type: 'line',
                    data: {
                        labels: data.t_labels,
                        datasets: [
                            {
                                label: 'z (관계의 긴장감)',
                                data: data.z_history,
                                borderColor: '#22D3EE', // Cyan
                                backgroundColor: '#22D3EE30',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'top', labels: { color: '#E5E7EB', font: { size: 14 } } },
                            tooltip: { mode: 'index', intersect: false, callbacks: { title: (items) => `Time: ${items[0].label}s` } }
                        },
                        scales: {
                            x: { title: { display: true, text: '시간 (Time)', color: '#9CA3AF' }, ticks: { color: '#9CA3AF', maxTicksLimit: 10 }, grid: { color: '#374151' } },
                            y: { title: { display: true, text: 'Z축 (긴장감)', color: '#9CA3AF' }, ticks: { color: '#9CA3AF' }, grid: { color: '#374151' } }
                        },
                        elements: { point: { radius: 0, hitRadius: 10, hoverRadius: 5 } }
                    }
                });
            }
        }

        // --- 4. 리포트 업데이트 ---
        // [수정] Math Error 해결: innerHTML에 LaTeX 직접 삽입 대신 DOM 요소로 구성한 후 MathJax 렌더링
        function updateAnalysis(params) {
            if (!aiConsultingReport || !expertAnalysisReport) {
                console.error("리포트 DOM 요소를 찾을 수 없습니다.");
                return;
            }

            const { sigma, rho, beta } = params;
            
            let aiConsulting = "";
            
            if (rho < 1) {
                aiConsulting = `
                    <p class="font-bold text-lg text-gray-400">진단: 무관심 (소멸)</p>
                    <p><strong>분석:</strong> \\(\\rho < 1\\) 입니다. 관계의 '혼돈 에너지'가 너무 낮아 어떤 감정(\\(x_0, y_0\\))에서 시작하든, 모든 궤적이 (0,0,0)으로 수렴하여 소멸합니다.</p>
                    <p><strong>컨설팅:</strong> 이것은 '안정'이 아니라 '소멸'입니다. 두 사람의 관계 에너지가 완전히 방전되었습니다. 관계를 되돌리려면 \\(\\rho\\)값을 높이는 외부의 강력한 자극이 필요합니다.</p>`;
            } else if (rho < 24.74) {
                aiConsulting = `
                    <p class="font-bold text-lg text-blue-400">진단: 안정적 (수렴)</p>
                    <p><strong>분석:</strong> \\(1 < \\rho < 24.74\\) 입니다. 관계가 '혼돈' 상태가 아닌 '안정된' 상태입니다. 3D 궤적은 2개의 고리를 그리지 않고, 2개의 '안정점' 중 하나로 수렴합니다.</p>
                    <p><strong>컨설팅:</strong> 축하합니다. 이 관계는 예측 가능하며 안정적입니다. '격정'은 없지만 '평화'가 있습니다. 궤적이 (0,0,0)이 아닌 특정 지점으로 수렴하는 것은 두 사람이 '무관심'이 아닌 '안정된 애정' 상태에 도달했음을 의미합니다.</p>`;
            } else {
                aiConsulting = `
                    <p class="font-bold text-lg text-pink-500">진단: 혼돈 (카오스)</p>
                    <p><strong>분석:</strong> \\(\\rho > 24.74\\) 입니다. 관계가 '혼돈(Chaotic)' 상태, 즉 '이상한 어트랙터(Strange Attractor)'에 진입했습니다. 3D 궤적이 2개의 고리(어트랙터)를 그리며, 두 고리 사이를 예측 불가능하게 오갑니다.</p>
                    <p><strong>컨설팅:</strong> 이 관계는 '격정적 롤러코스터'입니다. 예측 불가능하며, 초기 감정의 미세한 차이가 10초 뒤의 감정을 완전히 다르게 만듭니다(나비 효과). 관계가 파국으로 치닫지는 않지만, (0,0,0)으로 수렴하지도 않고 영원히 두 상태를 오갑니다.</p>`;
            }
            
            aiConsultingReport.innerHTML = aiConsulting;
            
            // [수정] Math Error 해결: LaTeX 수식을 올바르게 이스케이프 (백슬래시 2개 사용)
            expertAnalysisReport.innerHTML = `
                <p><strong>\\(\\sigma\\) (시그마): ${sigma.toFixed(2)}</strong><br>민감도입니다. 이 값이 클수록 \\(x\\)(영희)가 \\(y\\)(철수)의 감정 변화에 더 빠르고 격렬하게 반응합니다.</p>
                <p><strong>\\(\\rho\\) (로): ${rho.toFixed(2)}</strong><br>혼돈도입니다. 관계 에너지를 결정합니다. 이 값이 24.74를 넘으면 관계는 '혼돈' 상태로 진입합니다.</p>
                <p><strong>\\(\\beta\\) (베타): ${beta.toFixed(2)}</strong><br>안정성입니다. \\(z\\)(긴장감)가 스스로 해소되는 비율입니다. 이 값이 낮을수록 긴장감이 오래 지속됩니다.</p>
            `;
            
            // v24 원본 MathJax 렌더링 호출
            if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                MathJax.typesetPromise([aiConsultingReport, expertAnalysisReport, ...document.querySelectorAll('.accordion-content')]).catch(function (err) {
                    console.log('MathJax typeset error:', err);
                });
            }
        }

        // --- 5. 유틸리티 및 메인 실행 (v24 원본) ---
        function runFullSimulation() {
            const params = {};
            paramIds.forEach(id => {
                if (inputs[id]) {
                    params[id] = parseFloat(inputs[id].value);
                }
            });
            
            if (Object.keys(params).length !== paramIds.length) {
                console.warn("모든 파라미터 DOM이 아직 준비되지 않았습니다.");
                return;
            }
            
            const data = runLorenzSimulation(params);
            
            updateTrajectory(data.points);
            updateTimeSeriesChart(data);
            updateAnalysis(params);
        }

        function updateSliderLabel(id, value) {
            if (values[id]) {
                values[id].textContent = value.toFixed(id === 'beta' ? 2 : 1);
            }
        }

        function setParams(p) {
            Object.keys(p).forEach(key => {
                if(inputs[key]) {
                    inputs[key].value = p[key];
                    updateSliderLabel(key, p[key]);
                }
            });
            runFullSimulation();
        }

        function initializeApp() {
            console.log("v30: 모든 리소스 로드 완료 (window.load). 앱 초기화 시작...");
            
            // [v24] "비밀 코드": 모든 라이브러리가 로드되었는지 최종 확인
            if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined' || typeof Chart === 'undefined') {
                const errorMsg = "치명적 오류: 3D/2D 라이브러리 로드에 실패했습니다! (v30) 새로고침 후에도 문제가 지속되면 브라우저 캐시를 삭제해 주세요.";
                console.error(errorMsg);
                // AI 컨설팅 리포트에 오류 메시지 표시
                const errorReport = document.getElementById('ai-consulting-report');
                if (errorReport) {
                    errorReport.innerHTML = `<p class="text-red-400 font-bold">${errorMsg}</p>`;
                } else {
                    alert(errorMsg); // 최후의 수단
                }
                return; // 실행 중단
            }
            console.log("v30: 모든 라이브러리(THREE, OrbitControls, Chart) 로드 확인 완료.");

            aiConsultingReport = document.getElementById('ai-consulting-report');
            expertAnalysisReport = document.getElementById('expert-analysis-report');
            
            try {
                initThreeJS();
            } catch (e) {
                console.error("Three.js 초기화 실패:", e);
                aiConsultingReport.innerHTML = `<p class="text-red-400">오류: 3D 렌더링 엔진 초기화에 실패했습니다. ${e.message}</p>`;
                return;
            }
            
            paramIds.forEach(id => {
                inputs[id] = document.getElementById(`param-${id}`);
                values[id] = document.getElementById(`val-${id}`);
            });

            paramIds.forEach(id => {
                if(inputs[id]) {
                    inputs[id].addEventListener('input', (event) => {
                        const value = parseFloat(event.target.value);
                        updateSliderLabel(id, value);
                        runFullSimulation(); 
                    });
                }
            });
            
            document.getElementById('preset-chaotic').addEventListener('click', () => {
                setParams({ sigma: 10.0, rho: 28.0, beta: 2.67, x0: 1.0, y0: 1.0, z0: 1.0 });
            });
            document.getElementById('preset-stable').addEventListener('click', () => {
                setParams({ sigma: 10.0, rho: 20.0, beta: 2.67, x0: 1.0, y0: 1.0, z0: 1.0 });
            });
            document.getElementById('preset-indifferent').addEventListener('click', () => {
                setParams({ sigma: 10.0, rho: 0.5, beta: 2.67, x0: 10.0, y0: 10.0, z0: 10.0 });
            });
            document.getElementById('preset-intense').addEventListener('click', () => {
                setParams({ sigma: 10.0, rho: 45.0, beta: 2.67, x0: 1.0, y0: 1.0, z0: 1.0 });
            });
            
            document.querySelectorAll('.accordion-button').forEach(button => {
                button.addEventListener('click', () => {
                    const content = button.nextElementSibling;
                    const icon = button.querySelector('svg');
                    const isOpening = content.style.display !== 'block';
                    
                    document.querySelectorAll('.accordion-content').forEach(c => {
                        if (c !== content) {
                            c.style.display = 'none';
                            c.previousElementSibling.querySelector('svg').style.transform = 'rotate(0deg)';
                        }
                    });

                    if (isOpening) {
                        content.style.display = 'block';
                        icon.style.transform = 'rotate(180deg)';
                        if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                            MathJax.typesetPromise([content]).catch(function (err) {
                                console.log('MathJax typeset error:', err);
                            });
                        }
                    } else {
                         content.style.display = 'none';
                         icon.style.transform = 'rotate(0deg)';
                    }
                });
            });

            try {
                setParams({ sigma: 10.0, rho: 28.0, beta: 2.67, x0: 1.0, y0: 1.0, z0: 1.0 });
                console.log("앱 초기화 완료. (v30)");
            } catch (e) {
                console.error("초기 시뮬레이션 실행 실패:", e);
                if(aiConsultingReport) {
                    aiConsultingReport.innerHTML = `<p class="text-red-400">오류: 시뮬레이션 실행에 실패했습니다. ${e.message}</p>`;
                }
            }
        }
        
    </script>
</body>
</html>
