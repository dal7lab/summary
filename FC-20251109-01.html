<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í†µí•© íŒ©íŠ¸ ì²´í¬ ì‹œê°í™” ë¦¬í¬íŠ¸</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans KR', sans-serif; background-color: #121723; color: #d1d5db; }
        .chart-container { background-color: #1a2233; border: 1px solid #374151; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); padding: 1.5rem; transition: box-shadow 0.3s ease-in-out, border-color 0.3s; }
        .chart-container:hover { border-color: #4f5b70; }
        .tooltip { position: absolute; max-width: 320px; padding: 0.75rem; font-size: 0.875rem; background: rgba(45, 55, 72, 0.95); color: white; border-radius: 0.375rem; pointer-events: none; opacity: 0; transition: opacity 0.2s; line-height: 1.5; z-index: 10; }
        .tooltip-risk { font-weight: bold; color: #F1C40F; }
        .chart-title { font-size: 1.5rem; font-weight: 600; color: #f9fafb; margin-bottom: 1.5rem; text-align: center; }
        .legend-item { display: flex; align-items: center; font-size: 0.875rem; margin-right: 1.5rem; margin-bottom: 0.5rem; color: #9ca3af; }
        .legend-color { width: 0.85rem; height: 0.85rem; border-radius: 50%; margin-right: 0.5rem; }
        .axis-label, .axis text { fill: #9ca3af; }
        svg text {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-12">
            <h1 class="text-3xl md:text-4xl font-bold text-white">AIA ê³ ë°€ë„ ê°ì‚¬ ë¦¬í¬íŠ¸ ì‹œê°í™”</h1>
            <p class="text-lg text-gray-400 mt-2">ì´ 8ê°œ í•­ëª©ì— ëŒ€í•œ ì‹¬ì¸µ ë¶„ì„ ê²°ê³¼</p>
    <p class="text-md text-blue-300 mt-3 italic">ë¶„ì„ ëŒ€ìƒ: ë‚¨ì„± ìœ¡ì•„íœ´ì§ ì¦ê°€ ì¶”ì„¸ ê´€ë ¨ í…ìŠ¤íŠ¸</p>
      </header>
        <section class="mb-12">
            <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                <div class="lg:col-span-2 chart-container">
                    <h2 class="chart-title">ì¢…í•© ê²€ì¦ ê²°ê³¼</h2>
                    <div id="donut-chart" class="w-full h-80 flex items-center justify-center"></div>
                    <div id="donut-legend" class="flex flex-wrap justify-center mt-4"></div>
                </div>
                <div class="lg:col-span-3 chart-container">
                    <h2 class="chart-title">ë¦¬ìŠ¤í¬ ì§€ìˆ˜ë³„ ê²€ì¦ í˜„í™©</h2>
                    <div id="bar-chart" class="w-full h-80"></div>
                    <div id="bar-examples" class="mt-4 space-y-2 text-xs text-gray-400"></div>
                </div>
            </div>
        </section>
        <section>
            <div class="chart-container">
                <header class="text-center mb-6">
                    <h2 class="chart-title">ë¦¬ìŠ¤í¬-ì¹´í…Œê³ ë¦¬ë³„ íŒ©íŠ¸ ì²´í¬ ë¶„ì„</h2>
                    <p class="text-md text-gray-400 -mt-4">ë²„ë¸”ì˜ í¬ê¸°ëŠ” ë¦¬ìŠ¤í¬ ì§€ìˆ˜ë¥¼, ìƒ‰ìƒì€ ê²€ì¦ ê²°ê³¼ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.</p>
                </header>
                <div id="bubble-chart-legend" class="flex flex-wrap justify-center mb-6"></div>
                <div id="bubble-chart" class="w-full h-[650px]"></div>
            </div>
        </section>
    </div>
    <div class="tooltip"></div>
<script>
    const tooltip = d3.select(".tooltip");
    
    // ===================================================================
    // STATUS COLOR AND ICON DEFINITIONS (DO NOT MODIFY)
    // ===================================================================
    const statusColors = {
        'ê²€ì¦ ì™„ë£Œ': '#2ECC71',
        'ë§¥ë½ìƒ ì‚¬ì‹¤': '#3498DB',
        'ì¼ë¶€ í™•ì¸ë¨': '#F1C40F',
        'ë¶€ì •í™•í•¨': '#E74C3C',
        'í™•ì¸ ë¶ˆê°€': '#95A5A6'
    };
    
    const statusIcons = {
        'ê²€ì¦ ì™„ë£Œ': 'ğŸŸ¢',
        'ë§¥ë½ìƒ ì‚¬ì‹¤': 'ğŸ”µ',
        'ì¼ë¶€ í™•ì¸ë¨': 'ğŸŸ¡',
        'ë¶€ì •í™•í•¨': 'ğŸ”´',
        'í™•ì¸ ë¶ˆê°€': 'ğŸŸ£'
    };
    
    const statusOrder = ['ê²€ì¦ ì™„ë£Œ', 'ë§¥ë½ìƒ ì‚¬ì‹¤', 'ì¼ë¶€ í™•ì¸ë¨', 'ë¶€ì •í™•í•¨', 'í™•ì¸ ë¶ˆê°€'];
    
    // All 12 valid categories
    const validCategories = ['ê°œë…', 'í†µê³„', 'ì£¼ì¥', 'ì¸ìš©', 'ì‚¬ë¡€', 'ì‚¬ì‹¤', 'ëª©í‘œ', 'ë¶„ì„', 'ì „ëµ', 'ê°€ì„¤', 'ë¹„ìœ ', 'ìš©ì–´'];
    
    // ==================================================================
    // âœ… PHASE 4: Inject your SSoT-derived analysis data into the three variables below.
    // âš ï¸ CRITICAL REQUIREMENTS:
    // 1. All arrays MUST contain ACTUAL data from your Phase 4 aggregation (derived from Phase 3 SSoT list)
    // 2. Data MUST NOT be empty or placeholder.
    // 3. Data MUST be 100% synchronized with Section 1 (Summary) and Section 3 (Table).
    // ==================================================================
    
    // 100% SSoT-derived analysis data (N=8)
    const donutData = [
        { status: 'ê²€ì¦ ì™„ë£Œ', count: 4 },
        { status: 'ë§¥ë½ìƒ ì‚¬ì‹¤', count: 3 },
        { status: 'ì¼ë¶€ í™•ì¸ë¨', count: 0 },
        { status: 'ë¶€ì •í™•í•¨', count: 0 },
        { status: 'í™•ì¸ ë¶ˆê°€', count: 1 }
    ];
    
    const barData = [
        { 
            level: 'ê³ ìœ„í—˜ (80+)', 
            'ê²€ì¦ ì™„ë£Œ': 2, 
            'ë§¥ë½ìƒ ì‚¬ì‹¤': 0, 
            'ì¼ë¶€ í™•ì¸ë¨': 0, 
            'ë¶€ì •í™•í•¨': 0, 
            'í™•ì¸ ë¶ˆê°€': 0, 
            total: 2,
            example: '2025ë…„ ìƒë°˜ê¸° 36.4%' 
          },
          { 
            level: 'ì¤‘ìœ„í—˜ (50-79)', 
            'ê²€ì¦ ì™„ë£Œ': 2, 
            'ë§¥ë½ìƒ ì‚¬ì‹¤': 1, 
            'ì¼ë¶€ í™•ì¸ë¨': 0, 
            'ë¶€ì •í™•í•¨': 0, 
            'í™•ì¸ ë¶ˆê°€': 0, 
            total: 3,
            example: 'ì¤‘ì†Œê¸°ì—…ìœ¼ë¡œ í™•ì‚°' 
          },
          { 
            level: 'ì €ìœ„í—˜ (<50)', 
            'ê²€ì¦ ì™„ë£Œ': 0, 
            'ë§¥ë½ìƒ ì‚¬ì‹¤': 2, 
            'ì¼ë¶€ í™•ì¸ë¨': 0, 
            'ë¶€ì •í™•í•¨': 0, 
            'í™•ì¸ ë¶ˆê°€': 1, 
            total: 3,
            example: "'ë¶€ëª¨ì˜ ê³µë¶€ë ¥' ì „ì œ ì¡°ê±´" 
          }
    ];
    
    const bubbleData = [
        {no: 1, category: 'í†µê³„', risk: 95, fact: '2025ë…„ ìƒë°˜ê¸° ë‚¨ì„± ìœ¡ì•„íœ´ì§ì ë¹„ìœ¨ì€ 36.4%ì— ìœ¡ë°•.', status: 'ê²€ì¦ ì™„ë£Œ'},
        {no: 2, category: 'í†µê³„', risk: 92, fact: '(2025ë…„ ìƒë°˜ê¸° ë‚¨ì„± ìœ¡ì•„íœ´ì§ì ë¹„ìœ¨ì€) ì „ë…„ ë™ê¸° ëŒ€ë¹„ 54.2% ì¦ê°€.', status: 'ê²€ì¦ ì™„ë£Œ'},
        {no: 3, category: 'ë¶„ì„', risk: 78, fact: 'ë‚¨ì„± ìœ¡ì•„íœ´ì§ì´ ì¤‘ì†Œê¸°ì—…(ìš°ì„ ì§€ì›ëŒ€ìƒê¸°ì—…)ìœ¼ë¡œ í™•ì‚°ë˜ê³  ìˆë‹¤.', status: 'ê²€ì¦ ì™„ë£Œ'},
        {no: 4, category: 'ë¶„ì„', risk: 75, fact: 'ì •ë¶€ì˜ \'ë¶€ëª¨í•¨ê»˜ ìœ¡ì•„íœ´ì§ì œ\'ê°€ ê°•ë ¥í•œ ì œë„ì  ë“œë¼ì´ë¸Œê°€ ë¨.', status: 'ê²€ì¦ ì™„ë£Œ'},
        {no: 5, category: 'ì£¼ì¥', risk: 60, fact: '(ë‚¨ì„± ìœ¡ì•„íœ´ì§ ì¦ê°€) ì¶”ì„¸ëŠ” 2025ë…„ ë“¤ì–´ ë”ìš± ê°€ì†í™”ë˜ê³  ìˆë‹¤.', status: 'ë§¥ë½ìƒ ì‚¬ì‹¤'},
        {no: 6, category: 'ê°€ì„¤', risk: 45, fact: '(\'ë¬´ê´€ì‹¬\'í–ˆë˜ ì•„ë¹ ë“¤ì˜ ë¬¼ë¦¬ì  ê°€ì • ë³µê·€ê°€) \'ë¶€ëª¨ì˜ ê³µë¶€ë ¥\' ì‹œëŒ€ë¥¼ ì—° ì²« ë²ˆì§¸ ì „ì œ ì¡°ê±´ì´ë‹¤.', status: 'í™•ì¸ ë¶ˆê°€'},
        {no: 7, category: 'ë¹„ìœ ', risk: 30, fact: '\'ë¬´ê´€ì‹¬\'í–ˆë˜ ì•„ë¹ ë“¤ì´ ë¬¼ë¦¬ì ìœ¼ë¡œ ê°€ì •ìœ¼ë¡œ ëŒì•„ì˜¤ê¸° ì‹œì‘í–ˆë‹¤.', status: 'ë§¥ë½ìƒ ì‚¬ì‹¤'},
        {no: 8, category: 'ì£¼ì¥', risk: 25, fact: '(ë‚¨ì„± ìœ¡ì•„íœ´ì§ ì¦ê°€ëŠ”) ë‹¨ìˆœíˆ ëª‡ëª‡ \'ê¹¨ì–´ìˆëŠ”\' ì•„ë¹ ë“¤ì˜ ì„ íƒì´ ì•„ë‹ˆë‹¤.', status: 'ë§¥ë½ìƒ ì‚¬ì‹¤'}
    ];

    // ==================================================================
    // DATA VALIDATION AND ERROR CHECKING
    // ==================================================================
    
    // Validate status names
    if (donutData && donutData.length > 0) {
        donutData.forEach(item => {
            if (!statusColors[item.status]) {
                console.error(`Invalid status name in donutData: \"${item.status}\". Must be one of: ${statusOrder.join(', ')}`);
            }
        });
    }
    
    if (bubbleData && bubbleData.length > 0) {
        bubbleData.forEach(item => {
            if (!statusColors[item.status]) {
                console.error(`Invalid status name in bubbleData item ${item.no}: \"${item.status}\". Must be one of: ${statusOrder.join(', ')}`);
            }
            if (!validCategories.includes(item.category)) {
                console.error(`Invalid category in bubbleData item ${item.no}: \"${item.category}\". Must be one of: ${validCategories.join(', ')}`);
            }
        });
    }

    // ==================================================================
    // CHART RENDERING CODE (DO NOT MODIFY BELOW)
    // ==================================================================

    // DONUT CHART
    (() => {
        if (!donutData || donutData.length === 0) {
            console.error('âŒ Donut chart data is empty. Please inject actual data into the donutData array.');
            return;
        }
        const svg = d3.select("#donut-chart").append("svg").attr("width", "100%").attr("height", "100%").attr("viewBox", `0 0 320 320`).append("g").attr("transform", `translate(160, 160)`);
        const pie = d3.pie().value(d => d.count).sort(null);
        const arc = d3.arc().innerRadius(80).outerRadius(140);
        const total = d3.sum(donutData, d => d.count);
        svg.selectAll("path").data(pie(donutData)).enter().append("path")
            .attr("fill", d => statusColors[d.data.status] || '#95A5A6')
            .attr("d", arc).attr("stroke", "#1a2233").attr("stroke-width", "4px")
            .on("mouseover", (event, d) => { 
                const icon = statusIcons[d.data.status] || '';
                tooltip.style("opacity", 1).html(`<strong>${icon} ${d.data.status}</strong><br>${d.data.count}ê°œ (${(d.data.count / total * 100).toFixed(1)}%)`); 
                d3.select(event.currentTarget).transition().duration(200).attr("transform", "scale(1.05)"); 
            })
            .on("mousemove", (event) => tooltip.style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 28) + "px"))
            .on("mouseout", (event) => { tooltip.style("opacity", 0); d3.select(event.currentTarget).transition().duration(200).attr("transform", "scale(1)"); });
        svg.append("text").attr("text-anchor", "middle").attr("dy", "-0.5em").style("font-size", "2.5rem").style("font-weight", "bold").style("fill", "white").text(total);
        svg.append("text").attr("text-anchor", "middle").attr("dy", "1.0em").style("font-size", "1rem").style("fill", "#9ca3af").text("ì´ í•­ëª©");
        const legendContainer = d3.select("#donut-legend");
        donutData.forEach(({status}) => { 
            const li = legendContainer.append("div").attr("class", "legend-item"); 
            li.append("div").attr("class", "legend-color").style("background-color", statusColors[status] || '#95A5A6'); 
            li.append("span").text(status); 
        });
    })();
    
    // BAR CHART
    (() => {
        if (!barData || barData.length === 0) {
            console.error('âŒ Bar chart data is empty. Please inject actual data into the barData array.');
            return;
        }
        const margin = { top: 20, right: 20, bottom: 40, left: 60 };
        const container = d3.select("#bar-chart");
        const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
        const height = container.node().getBoundingClientRect().height - margin.top - margin.bottom;
        const svg = container.append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Remove duplicate risk levels
        const uniqueBarData = [];
        const seenLevels = new Set();
        barData.forEach(item => {
            if (!seenLevels.has(item.level)) {
                seenLevels.add(item.level);
                uniqueBarData.push(item);
            } else {
                console.warn(`âš ï¸ Duplicate risk level detected and removed: \"${item.level}\"`);
            }
        });
        
        const stack = d3.stack().keys(statusOrder.filter(key => uniqueBarData.some(d => d[key] > 0)));
        const series = stack(uniqueBarData);
        const x = d3.scaleBand().domain(uniqueBarData.map(d => d.level)).range([0, width]).padding(0.3);
        const y = d3.scaleLinear().domain([0, d3.max(uniqueBarData, d => d.total)]).nice().range([height, 0]);
        
        svg.append("g").selectAll("g").data(series).join("g")
            .attr("fill", d => statusColors[d.key] || '#95A5A6')
            .selectAll("rect").data(d => d).join("rect")
            .attr("x", d => x(d.data.level))
            .attr("y", d => y(d[1]))
            .attr("height", d => Math.max(0, y(d[0]) - y(d[1])))
            .attr("width", x.bandwidth())
            .on("mouseover", (event, d) => { 
                const key = d3.select(event.currentTarget.parentNode).datum().key;
                const icon = statusIcons[key] || '';
                tooltip.style("opacity", 1).html(`<strong>${d.data.level}</strong><br>${icon} ${key}: ${d.data[key]}ê°œ`); 
            })
            .on("mousemove", (event) => tooltip.style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 28) + "px"))
            .on("mouseout", () => tooltip.style("opacity", 0));
        
        svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x)).call(g => g.select(".domain").remove()).selectAll("text").attr("class", "axis-label");
        svg.append("g").call(d3.axisLeft(y).ticks(5)).call(g => g.select(".domain").remove()).call(g => g.selectAll(".tick line").clone().attr("x2", width).attr("stroke", "#374151").attr("stroke-opacity", 0.5)).selectAll("text").attr("class", "axis-label");
        svg.append("text").attr("x", -10).attr("y", -10).attr("class", "axis-label").style("font-size", "0.875rem").style("font-weight", "500").attr("text-anchor", "start").text("í•­ëª© ìˆ˜");
        
        // Add examples below the chart
        const examplesContainer = d3.select("#bar-examples");
        uniqueBarData.forEach(item => {
            if (item.example) {
                examplesContainer.append("div").html(`<strong>${item.level}</strong> ì˜ˆì‹œ: ${item.example}`);
            }
        });
    })();
    
    // BUBBLE CHART
    (() => {
        if (!bubbleData || bubbleData.length === 0) {
            console.error('âŒ Bubble chart data is empty. Please inject actual data into the bubbleData array.');
            return;
        }
        const margin = {top: 50, right: 30, bottom: 60, left: 80};
        const container = d3.select("#bubble-chart");
        const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
        const height = container.node().getBoundingClientRect().height - margin.top - margin.bottom;
        const svg = container.append("svg").attr("width", "100%").attr("height", "100%").attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Calculate average risk per category for center-weighted ordering
        const categoryRiskMap = {};
        bubbleData.forEach(d => {
            if (!categoryRiskMap[d.category]) {
                categoryRiskMap[d.category] = { total: 0, count: 0 };
            }
            categoryRiskMap[d.category].total += d.risk;
            categoryRiskMap[d.category].count += 1;
        });
        
        const categoryAvgRisk = Object.keys(categoryRiskMap).map(cat => ({
            category: cat,
            avgRisk: categoryRiskMap[cat].total / categoryRiskMap[cat].count
        })).sort((a, b) => b.avgRisk - a.avgRisk);
        
        console.log(`âœ… Categories found in data: ${categoryAvgRisk.length}`, categoryAvgRisk.map(c => c.category));
        
        // Arrange categories with highest risk in center
        const arrangedCategories = [];
        const leftSide = [];
        const rightSide = [];
        categoryAvgRisk.forEach((item, idx) => {
            if (idx === 0) {
                arrangedCategories.push(item.category);
            } else if (idx % 2 === 1) {
                leftSide.unshift(item.category);
            } else {
                rightSide.push(item.category);
            }
        });
        const categories = [...leftSide, ...arrangedCategories, ...rightSide];
        
        const statuses = statusOrder.slice().reverse();
        const x = d3.scalePoint().domain(categories).range([0, width]).padding(0.5);
        const y = d3.scalePoint().domain(statuses).range([height, 0]).padding(0.5);
        const radius = d3.scaleSqrt().domain(d3.extent(bubbleData, d => d.risk)).range([4, 32]);
        
        svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x)).call(g => g.select(".domain").remove()).selectAll("text").attr("class", "axis-label").style("font-size", "0.875rem");
        svg.selectAll("yGrid").data(statuses).enter().append("line").attr("x1", 0).attr("x2", width).attr("y1", d => y(d)).attr("y2", d => y(d)).attr("stroke", "#374151").attr("stroke-dasharray", "2,2");
        svg.append("g").call(d3.axisLeft(y).tickSize(0).tickPadding(10)).select(".domain").remove();
        svg.selectAll(".tick text").attr("class", "axis-label").style("font-size", "0.875rem");
        
        const nodes = svg.selectAll(".node").data(bubbleData).enter().append("circle").attr("class", "node")
            .attr("r", d => radius(d.risk))\
            .style("fill", d => statusColors[d.status] || '#95A5A6')
            .style("fill-opacity", 0.7)\
            .style("stroke", d => statusColors[d.status] || '#95A5A6')
            .style("stroke-width", 2)\
            .on("mouseover", (event, d) => { 
                const icon = statusIcons[d.status] || '';
                tooltip.style("opacity", 1).html(`<strong>[No.${d.no}] [${d.category}]</strong><br>${d.fact}<br><span class="tooltip-risk">Risk: ${d.risk}</span><br>${icon} ${d.status}`); 
                d3.select(event.currentTarget).style("fill-opacity", 1).style("stroke-width", 3); 
            })\
            .on("mousemove", (event) => tooltip.style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 28) + "px"))
            .on("mouseout", (event) => { tooltip.style("opacity", 0); d3.select(event.currentTarget).style("fill-opacity", 0.7).style("stroke-width", 2); });
        
        d3.forceSimulation(bubbleData)\
            .force("x", d3.forceX(d => x(d.category)).strength(0.15))\
            .force("y", d3.forceY(d => y(d.status)).strength(1.2))\
            .force("collide", d3.forceCollide(d => radius(d.risk) + 2).strength(0.95))\
            .force("bounds", () => {\
                bubbleData.forEach(d => {\
                    const r = radius(d.risk);\
                    d.x = Math.max(r, Math.min(width - r, d.x));\
                    d.y = Math.max(r, Math.min(height - r, d.y));\
                });\
            })\
            .on("tick", () => nodes.attr("cx", d => d.x).attr("cy", d => d.y));
        
        const legendContainer = d3.select("#bubble-chart-legend");
        statusOrder.slice().reverse().forEach(status => { 
            const li = legendContainer.append("div").attr("class", "legend-item"); 
            li.append("div").attr("class", "legend-color").style("background-color", statusColors[status]); 
            li.append("span").text(status); 
        });
    })();
</script>
</body>
</html>
